% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/squash.R
\name{datetime_squash}
\alias{datetime_squash}
\title{Flatten datetime ranges into a phinterval}
\usage{
datetime_squash(
  start,
  end,
  by = NULL,
  na.rm = TRUE,
  empty_to = c("hole", "na", "empty"),
  order_by = FALSE
)
}
\arguments{
\item{start}{\verb{[POSIXct / POSIXlt / Date]}

A vector of start times. Must be recyclable with \code{end}.}

\item{end}{\verb{[POSIXct / POSIXlt / Date]}

A vector of end times. Must be recyclable with \code{start}.}

\item{by}{\verb{[vector / data.frame / NULL]}

An optional grouping vector or data frame. When provided, \code{start[i]} and
\code{end[i]} ranges are grouped by \code{by[i]} and merged separately within each
group. If \code{NULL} (the default), all ranges are merged into a single
phinterval element. Must be recyclable with the common length of \code{start}
and \code{end}.

\code{by} must be a vector in the vctrs sense. See \verb{[vctrs::obj_is_vector()]}
for details.}

\item{na.rm}{\verb{[TRUE / FALSE]}

Should \code{NA} ranges be removed before squashing? If \code{FALSE} and any \code{NA}
ranges are present, the result for that group is \code{NA}.}

\item{empty_to}{\verb{["hole" / "na" / "empty"]}

How to handle empty inputs (length-0 vectors or groups with only \code{NA} values
when \code{na.rm = TRUE}):
\itemize{
\item \code{"hole"} (default): Return a hole
\item \code{"na"}: Return an \code{NA} phinterval
\item \code{"empty"}: Return a length-0 phinterval vector
}}

\item{order_by}{\verb{[TRUE / FALSE]}

Should the output be ordered by the values in \code{by}? If \code{FALSE} (the default),
the output order matches the first appearance of each group in \code{by}. If \code{TRUE},
the output is sorted by the unique values of \code{by}. Only used when \code{by} is not
\code{NULL}.}
}
\value{
When \code{by = NULL}, a length-1 \verb{<phinterval>} vector (or length-0 if the input
is empty and \code{empty_to = "empty"}).

When \code{by} is provided, a \verb{<phinterval>} vector with one element per unique
value of \code{by}.
}
\description{
\code{datetime_squash()} merges overlapping or adjacent datetime ranges into a
minimal set of non-overlapping, non-adjacent time spans, returning a
\verb{<phinterval>} vector.

When \code{by = NULL} (the default), all ranges are merged into a single
phinterval element. When \code{by} is provided, ranges are grouped and merged
separately within each group, creating one phinterval element per unique
value of \code{by}.
}
\examples{
starts <- as.Date(c("2000-01-01", "2000-01-03", "2000-01-11"))
ends <- as.Date(c("2000-01-05", "2000-01-09", "2000-01-12"))

# Merge all ranges into a single phinterval
datetime_squash(starts, ends)

# Squash within groups
datetime_squash(starts, ends, by = c(1, 1, 2))

# NA ranges are removed by default
datetime_squash(
  c(starts, NA),
  c(ends, NA)
)

# Set na.rm = FALSE to propagate NA values
datetime_squash(
  c(starts, NA),
  c(ends, NA),
  na.rm = FALSE
)

# Recycling start and end
datetime_squash(
  start = as.Date("2000-01-01"),
  end = as.Date(c("2000-01-05", "2000-01-10", "2000-01-15"))
)

# Control output order with order_by
datetime_squash(
  starts,
  ends,
  by = c(2, 2, 1),
  order_by = TRUE
)

}
