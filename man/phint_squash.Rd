% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/squash.R
\name{phint_squash}
\alias{phint_squash}
\title{Flatten a phinterval}
\usage{
phint_squash(
  phint,
  by = NULL,
  na.rm = TRUE,
  empty_to = c("hole", "na", "empty"),
  order_by = FALSE
)
}
\arguments{
\item{phint}{\verb{[phinterval / Interval]}

A \verb{<phinterval>} or \verb{<Interval>} vector.}

\item{by}{\verb{[vector / data.frame / NULL]}

An optional grouping vector or data frame. When provided, intervals are
grouped by \code{by} and merged separately within each group. If \code{NULL} (the
default), all intervals are merged into a single phinterval element.

\code{by} must be a vector in the vctrs sense. See \verb{[vctrs::obj_is_vector()]}
for details.}

\item{na.rm}{\verb{[TRUE / FALSE]}

Should \code{NA} elements be removed before squashing? If \code{FALSE} and any \code{NA}
elements are present, the result for that group is \code{NA}. Defaults to \code{TRUE}.}

\item{empty_to}{\verb{["hole" / "na" / "empty"]}

How to handle empty inputs (length-0 vectors):
\itemize{
\item \code{"hole"} (default): Return a hole
\item \code{"na"}: Return an \code{NA} phinterval
\item \code{"empty"}: Return a length-0 phinterval vector
}}

\item{order_by}{\verb{[TRUE / FALSE]}

Should the output be ordered by the values in \code{by}? If \code{FALSE} (the default),
the output order matches the first appearance of each group in \code{by}. If \code{TRUE},
the output is sorted by the unique values of \code{by}. Only used when \code{by} is not
\code{NULL}.}
}
\value{
When \code{by = NULL}, a length-1 \verb{<phinterval>} vector (or length-0 if the input
is empty and \code{empty_to = "empty"}).

When \code{by} is provided, a \verb{<phinterval>} vector with one element per unique
value of \code{by}.
}
\description{
\code{phint_squash()} merges overlapping or adjacent intervals into a minimal set
of non-overlapping, non-adjacent time spans.

When \code{by = NULL} (the default), all intervals are merged into a single
phinterval element. When \code{by} is provided, intervals are grouped and merged
separately within each group, creating one phinterval element per unique
value of \code{by}.
}
\details{
This function is particularly useful in aggregation workflows with
\code{\link[dplyr:summarise]{dplyr::summarize()}} to combine intervals within groups.
}
\examples{
jan_1_to_5 <- interval(as.Date("2000-01-01"), as.Date("2000-01-05"))
jan_3_to_9 <- interval(as.Date("2000-01-03"), as.Date("2000-01-09"))
jan_11_to_12 <- interval(as.Date("2000-01-11"), as.Date("2000-01-12"))

# Merge all intervals into a single phinterval
phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12))

# NA values are removed by default
phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12, NA))

# Set na.rm = FALSE to propagate NA values
phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12, NA), na.rm = FALSE)

# Squash within groups
phint_squash(
  c(jan_1_to_5, jan_3_to_9, jan_11_to_12),
  by = c(1, 1, 2)
)

# Control output order with order_by
phint_squash(
  c(jan_1_to_5, jan_3_to_9, jan_11_to_12),
  by = c(2, 2, 1),
  order_by = TRUE
)

# Use empty_to to determine the result of empty inputs
empty <- phinterval()
phint_squash(empty, empty_to = "hole")
phint_squash(empty, empty_to = "na")
phint_squash(empty, empty_to = "empty")

}
\seealso{
\code{\link[=datetime_squash]{datetime_squash()}}
}
