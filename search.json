[{"path":"https://ethansansom.github.io/phinterval/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2026 phinterval authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to phinterval","text":"phinterval package extends {lubridate} support disjoint (“holey”) empty time spans. implements <phinterval> vector class, generalization standard contiguous <Interval>, can represent: Contiguous spans: contiguous interval bounded start end point (e.g., year 2025). Empty spans: set containing time points (e.g., intersection life Napoleon’s). Disjoint spans: set multiple time spans separated gaps (e.g., days attended school, excluding weekends holidays). package designed easily integrate existing lubridate workflows. <Interval> vector can converted equivalent <phinterval> vector using as_phinterval(), phinterval functions accept either <Interval> <phinterval> inputs.","code":""},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"when-time-isnt-continuous","dir":"Articles","previous_headings":"","what":"When Time Isn’t Continuous","title":"Introduction to phinterval","text":"Certain set operations time spans naturally produce empty disjoint results, difficult represent using standard interval. section illustrates several edge cases using months January November 2025, along full calendar year.","code":"jan <- interval(ymd(\"2025-01-01\"), ymd(\"2025-02-01\")) nov <- interval(ymd(\"2025-11-01\"), ymd(\"2025-12-01\")) full_2025 <- interval(ymd(\"2025-01-01\"), ymd(\"2026-01-01\"))"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"empty-intersections","dir":"Articles","previous_headings":"When Time Isn’t Continuous","what":"Empty Intersections","title":"Introduction to phinterval","text":"January November overlap, intersection contain time. lubridate resolved coercing intersection NA, phinterval returns <hole>, explicitly represents empty span time. distinction matters performing downstream calculations. example, counting number days contained January November:","code":"lubridate::intersect(jan, nov) #> [1] NA--NA  phint_intersect(jan, nov) #> <phinterval<UTC>[1]> #> [1] <hole> lubridate::intersect(jan, nov) / duration(days = 1) #> [1] NA  phint_intersect(jan, nov) / duration(days = 1) #> [1] 0"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"punching-holes-in-intervals","dir":"Articles","previous_headings":"When Time Isn’t Continuous","what":"Punching Holes in Intervals","title":"Introduction to phinterval","text":"Next, consider subtracting month November full year 2025. result two disjoint spans, January October December, can’t represented single interval. result, lubridate raises error. phinterval, disjoint span represented single object explicit gap.","code":"try(lubridate::setdiff(full_2025, nov)) #> Error in setdiff.Interval(full_2025, nov) :  #>   Cases 1 result in discontinuous intervals.  phint_setdiff(full_2025, nov) #> <phinterval<UTC>[1]> #> [1] {2025-01-01--2025-11-01, 2025-12-01--2026-01-01}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"unions-of-non-overlapping-spans","dir":"Articles","previous_headings":"When Time Isn’t Continuous","what":"Unions of Non-Overlapping Spans","title":"Introduction to phinterval","text":"Similarly, union January November contains gap February October. case lubridate returns span beginning January end November, implicitly filling gap. two disjoint months represented explicitly using phinterval.","code":"lubridate::union(jan, nov) #> [1] 2025-01-01 UTC--2025-12-01 UTC  phint_union(jan, nov) #> <phinterval<UTC>[1]> #> [1] {2025-01-01--2025-02-01, 2025-11-01--2025-12-01}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"subtracting-an-interval-from-itself","dir":"Articles","previous_headings":"When Time Isn’t Continuous","what":"Subtracting an Interval from Itself","title":"Introduction to phinterval","text":"Finally, consider subtracting interval . Intuitively, result empty time span. case, lubridate returns original interval, phinterval returns <hole>.","code":"lubridate::setdiff(jan, jan) #> [1] 2025-01-01 UTC--2025-02-01 UTC  phint_setdiff(jan, jan) #> <phinterval<UTC>[1]> #> [1] <hole>"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"case-study-employment-history","dir":"Articles","previous_headings":"","what":"Case Study: Employment History","title":"Introduction to phinterval","text":"phinterval package useful working tabular data vectorized workflows. illustrate , ’ll consider abridged employment history several characters television show Succession. Suppose know Greg, Tom, Shiv went Christmas vacation December 2017. want analyze time spent working, exclude time vacation, might try subtract vacation interval span jobs. However, approach breaks vacation falls strictly within job interval, Shiv’s Political Consultant role. Handling correctly surprisingly involved. One option split Shiv’s job two rows (one pre-vacation one post-vacation), breaking one-row-per-job structure data. Another represent job list intervals, complicating downstream analysis. main purpose phinterval avoid workarounds, providing drop-replacements lubridate interval functions. phinterval functions accept either <Interval> <phinterval> inputs, existing code can typically adapted simply replacing lubridate function phinterval counterpart.","code":"jobs <- tribble(   ~name,   ~job_title,             ~start,        ~end,   \"Greg\",  \"Mascot\",               \"2018-01-01\",  \"2018-06-03\",   \"Greg\",  \"Executive Assistant\",  \"2018-06-10\",  \"2020-04-01\",   \"Greg\",  \"Chief of Staff\",       \"2020-03-01\",  \"2020-11-28\",   \"Tom\",   \"Chairman\",             \"2019-05-01\",  \"2020-11-10\",   \"Tom\",   \"CEO\",                  \"2020-11-10\",  \"2020-12-31\",   \"Shiv\",  \"Political Consultant\", \"2017-01-01\",  \"2019-04-01\" ) vacation <- interval(ymd(\"2017-12-23\"), ymd(\"2017-12-29\")) try(   jobs |>     mutate(       span = interval(start, end),       span = setdiff(span, vacation)     ) |>     select(name, job_title, span) ) #> Error in mutate(jobs, span = interval(start, end), span = setdiff(span,  :  #>   ℹ In argument: `span = setdiff(span, vacation)`. #> Caused by error in `setdiff.Interval()`: #> ! Cases 6 result in discontinuous intervals. jobs |>   mutate(     span = interval(start, end),     span = phint_setdiff(span, vacation)   ) |>   select(name, job_title, span) #> # A tibble: 6 × 3 #>   name  job_title            span                        #>   <chr> <chr>                <phint<UTC>>                #> 1 Greg  Mascot               {2018-01-01--2018-06-03}    #> 2 Greg  Executive Assistant  {2018-06-10--2020-04-01}    #> 3 Greg  Chief of Staff       {2020-03-01--2020-11-28}    #> 4 Tom   Chairman             {2019-05-01--2020-11-10}    #> 5 Tom   CEO                  {2020-11-10--2020-12-31}    #> 6 Shiv  Political Consultant {2017-01-01-[2]-2019-04-01}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"merging-intervals","dir":"Articles","previous_headings":"Case Study: Employment History","what":"Merging Intervals","title":"Introduction to phinterval","text":"Suppose want analyze total time character spent employed, without distinguishing individual jobs. can done using phint_squash(), aggregates vector intervals minimal set non-overlapping spans within scalar <phinterval>. Notice : Greg multiple disjoint employment periods, preserved separate spans within single <phinterval> element. Tom held two back--back positions (Chairman followed CEO), phint_squash() correctly merges single contiguous span. argument phint_squash() datetime_squash() (takes start end times directly) can used place dplyr::group_by(). example equivalent previous code usually several times faster. dplyr::summarize(), argument can vector data frame support multiple grouping columns. return dataset one-row-per-span format, use phint_unnest(), converts <phinterval> element separate rows:","code":"employment <- jobs |>   mutate(span = interval(start, end)) |>   group_by(name) |>   summarize(employed = phint_squash(span))  employment #> # A tibble: 3 × 2 #>   name  employed                                         #>   <chr> <phint<UTC>>                                     #> 1 Greg  {2018-01-01--2018-06-03, 2018-06-10--2020-11-28} #> 2 Shiv  {2017-01-01--2019-04-01}                         #> 3 Tom   {2019-05-01--2020-12-31} datetime_squash(   start = ymd(jobs$start),   end = ymd(jobs$end),   by = jobs$name,   keep_by = TRUE,   order_by = TRUE ) #> # A tibble: 3 × 2 #>   by    phint                                            #>   <chr> <phint<UTC>>                                     #> 1 Greg  {2018-01-01--2018-06-03, 2018-06-10--2020-11-28} #> 2 Shiv  {2017-01-01--2019-04-01}                         #> 3 Tom   {2019-05-01--2020-12-31} employment |>   reframe(phint_unnest(employed, key = name)) #> # A tibble: 4 × 3 #>   key   start               end                 #>   <chr> <dttm>              <dttm>              #> 1 Greg  2018-01-01 00:00:00 2018-06-03 00:00:00 #> 2 Greg  2018-06-10 00:00:00 2020-11-28 00:00:00 #> 3 Shiv  2017-01-01 00:00:00 2019-04-01 00:00:00 #> 4 Tom   2019-05-01 00:00:00 2020-12-31 00:00:00"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"finding-gaps","dir":"Articles","previous_headings":"Case Study: Employment History","what":"Finding Gaps","title":"Introduction to phinterval","text":"analyze periods unemployment, need identify gaps employment intervals. phint_invert() function returns gaps spans <phinterval>. Greg unemployed 7 days time Mascot role Executive Assistant. Tom Shiv gaps within respective employment timelines, represented <hole>.","code":"unemployment <- employment |>   mutate(     # Find the gaps between jobs     unemployed = phint_invert(employed),          # Calculate duration of unemployment     days_unemployed = unemployed / ddays(1)   ) |>   select(name, unemployed, days_unemployed)  unemployment #> # A tibble: 3 × 3 #>   name  unemployed               days_unemployed #>   <chr> <phint<UTC>>                       <dbl> #> 1 Greg  {2018-06-03--2018-06-10}               7 #> 2 Shiv  <hole>                                 0 #> 3 Tom   <hole>                                 0"},{"path":[]},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"abutting-intervals-and-intersection","dir":"Articles","previous_headings":"Edge Cases and Gotchas","what":"Abutting Intervals and Intersection","title":"Introduction to phinterval","text":"Manipulating abutting intervals (intervals share endpoint) can produce sometimes unexpected results. demonstrate, consider time within Monday Tuesday November 2025. default, intervals <phinterval> <Interval> vectors inclusive endpoints, meaning midnight Monday, November 11th, 2025 falls within monday tuesday: result, intersection monday tuesday instantaneous interval midnight_monday. Perhaps surprisingly, also means intersection monday complement empty, consists two endpoints monday. bounds argument phint_overlaps(), phint_within(), phint_intersect() controls behavior. bounds = \"()\", endpoints treated exclusive: exclusive endpoints, monday tuesday longer overlap, intersection empty. instantaneous interval (point, point) open bounds mathematically undefined, convenience allow points exist. bounds = \"()\", instants endpoint interval outside interval, instants middle interval considered within : consider instantaneous intervals empty, use phint_sift() remove instants interval vector:","code":"monday <- interval(ymd(\"2025-11-10\"), ymd(\"2025-11-11\")) tuesday <- interval(ymd(\"2025-11-11\"), ymd(\"2025-11-12\")) midnight_monday <- ymd_hms(\"2025-11-11 00:00:00\") phint_within(midnight_monday, monday) #> [1] TRUE phint_within(midnight_monday, tuesday) #> [1] TRUE phint_intersect(monday, tuesday) == as_phinterval(midnight_monday) #> [1] TRUE not_monday <- phint_complement(monday) not_monday #> <phinterval<UTC>[1]> #> [1] {-Inf--2025-11-10, 2025-11-11--Inf}  phint_intersect(monday, not_monday) #> <phinterval<UTC>[1]> #> [1] {2025-11-10--2025-11-10, 2025-11-11--2025-11-11} phint_overlaps(monday, tuesday, bounds = \"()\") #> [1] FALSE phint_intersect(monday, tuesday, bounds = \"()\") #> <phinterval<UTC>[1]> #> [1] <hole> monday_at_9AM <- as_phinterval(ymd_hms(\"2025-11-10 00:09:00\")) phint_within(monday_at_9AM, monday, bounds = \"()\") #> [1] TRUE phint_within(midnight_monday, monday, bounds = \"()\") #> [1] FALSE phint <- phint_squash(c(monday_at_9AM, tuesday)) phint #> <phinterval<UTC>[1]> #> [1] {2025-11-10 00:09:00--2025-11-10 00:09:00, 2025-11-11 00:00:00--2025-11-12 00:00:00}  phint_sift(phint) #> <phinterval<UTC>[1]> #> [1] {2025-11-11--2025-11-12}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"instantaneous-intervals-and-set-difference","dir":"Articles","previous_headings":"Edge Cases and Gotchas","what":"Instantaneous Intervals and Set Difference","title":"Introduction to phinterval","text":"phinterval elements composed non-overlapping, non-adjacent spans, “punching” instantaneous hole interval using phint_setdiff() effect interval. removing single point interval [start, end] theoretically split [start, point) (point, end], practice adjacent pieces immediately merged back together: create gaps, must remove interval non-zero duration.","code":"monday_noon <- as_phinterval(ymd_hms(\"2025-11-10 12:00:00\")) monday_lunch_break <- interval(   ymd_hms(\"2025-11-10 12:00:00\"),    ymd_hms(\"2025-11-10 13:00:00\") )  phint_setdiff(monday, monday_lunch_break) # Removes a non-zero interval #> <phinterval<UTC>[1]> #> [1] {2025-11-10 00:00:00--2025-11-10 12:00:00, 2025-11-10 13:00:00--2025-11-11 00:00:00} phint_setdiff(monday, monday_noon)        # Instantaneous - no effect #> <phinterval<UTC>[1]> #> [1] {2025-11-10--2025-11-11}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"time-zones","dir":"Articles","previous_headings":"Edge Cases and Gotchas","what":"Time Zones","title":"Introduction to phinterval","text":"ensure <Interval> vector can represented equivalent <phinterval> vector, phinterval() constructor accepts time zone permitted interval(), including unrecognized zones. <phinterval> unrecognized time zone formatted, time points displayed using UTC time zone: is_recognized_tzone() function can used check whether time zone recognized: datetime vectors, <POSIXct>, allowed NA time zone. converted <phinterval>, missing time zone silently replaced UTC: Operations combine two interval vectors, phint_union(), use time zone first argument. first argument’s time zone \"\" (user’s local time zone), second argument’s time zone used instead.","code":"intvl <- interval(ymd(\"2020-01-01\"), ymd(\"2020-01-02\"), tzone = \"nozone\") phint <- phinterval(ymd(\"2020-01-01\"), ymd(\"2020-01-02\"), tzone = \"nozone\") intvl == phint #> [1] TRUE print(phint) #> <phinterval<nozone>[1]> #> [1] {2020-01-01--2020-01-02} is_recognized_tzone(\"America/New_York\") #> [1] TRUE is_recognized_tzone(\"nozone\") #> [1] FALSE is_recognized_tzone(NA_character_) #> [1] FALSE na_zoned <- as.POSIXct(\"2021-01-01\", tz = NA_character_) as_phinterval(na_zoned) #> <phinterval<UTC>[1]> #> [1] {2021-01-01--2021-01-01} int_est <- interval(ymd(\"2020-01-01\"), ymd(\"2020-01-02\"), tzone = \"EST\") int_utc <- interval(ymd(\"2020-01-01\"), ymd(\"2020-01-02\"), tzone = \"UTC\") int_lcl <- interval(ymd(\"2020-01-01\"), ymd(\"2020-01-02\"), tzone = \"\")  phint_union(int_est, int_utc) #> <phinterval<EST>[1]> #> [1] {2019-12-31 19:00:00--2020-01-01 19:00:00} phint_union(int_utc, int_est) #> <phinterval<UTC>[1]> #> [1] {2020-01-01--2020-01-02} phint_union(int_lcl, int_est) #> <phinterval<EST>[1]> #> [1] {2019-12-31 19:00:00--2020-01-01 19:00:00}"},{"path":"https://ethansansom.github.io/phinterval/articles/phinterval.html","id":"comparison-with-datetime-vectors","dir":"Articles","previous_headings":"Edge Cases and Gotchas","what":"Comparison with Datetime Vectors","title":"Introduction to phinterval","text":"Comparison operators (<=, <, >, >=, ==) work unexpected ways comparing datetime vectors (<Date>, <POSIXct>, <POSIXlt>) <phinterval> <Interval> vectors. example: intended behavior, use as_phinterval() convert datetime vectors equivalent <phinterval> first.","code":"span <- phinterval(ymd(\"2000-08-05\"), ymd(\"2000-11-29\")) date <- ymd(\"2021-01-01\")  span == date #>   size starts   ends  #>  FALSE     NA     NA span == as_phinterval(date) #> [1] FALSE"},{"path":"https://ethansansom.github.io/phinterval/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ethan Sansom. Author, maintainer, copyright holder.","code":""},{"path":"https://ethansansom.github.io/phinterval/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sansom E (2026). phinterval: Set Operations Time Intervals. R package version 1.0.0, https://github.com/EthanSansom/phinterval.","code":"@Manual{,   title = {phinterval: Set Operations on Time Intervals},   author = {Ethan Sansom},   year = {2026},   note = {R package version 1.0.0},   url = {https://github.com/EthanSansom/phinterval}, }"},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"phinterval-","dir":"","previous_headings":"","what":"Set Operations on Time Intervals","title":"Set Operations on Time Intervals","text":"phinterval package representing manipulating time spans may contain gaps. implements <phinterval> (think “potentially-holey-interval”) vector class, designed extension {lubridate} <Interval>, represent spans time contiguous, disjoint, empty, missing. Functionality manipulating spans includes: Merging overlapping adjacent intervals non-overlapping sets time spans. Performing set operations: union, intersection, difference, complement. Testing whether time spans, dates, times fall within one another overlap.","code":""},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Set Operations on Time Intervals","text":"Install released version CRAN : can install development version phinterval GitHub :","code":"install.packages(\"phinterval\") # install.packages(\"pak\") pak::pak(\"EthanSansom/phinterval\")"},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Set Operations on Time Intervals","text":"element <phinterval> vector set non-overlapping non-adjacent intervals. scalar intervals (one span per element), phinterval() works like lubridate::interval(): create phintervals multiple disjoint spans per element, use argument group intervals. Overlapping adjacent spans within group automatically merged: Graphically, elements phint represented :  cases, <phinterval> vector appear result manipulating <Interval> vectors. example, phint_squash() flattens vector time spans scalar <phinterval>. squashed intervals contain set time spans within input intervals, without duplication.","code":"library(phinterval) library(lubridate, warn.conflicts = FALSE)  # Create scalar phintervals (equivalent to interval()) phinterval(   start = ymd(c(\"2000-01-01\", \"2000-01-03\", \"2000-01-04\")),   end = ymd(c(\"2000-01-02\", \"2000-01-05\", \"2000-01-09\")) ) #> <phinterval<UTC>[3]> #> [1] {2000-01-01--2000-01-02} {2000-01-03--2000-01-05} {2000-01-04--2000-01-09} # Create a phinterval with disjoint spans using the by argument phint <- phinterval(   start = ymd(c(\"2000-01-03\", \"2000-01-01\", \"2000-01-04\")),   end = ymd(c(\"2000-01-05\", \"2000-01-02\", \"2000-01-09\")),   by = c(1, 2, 2) ) phint #> <phinterval<UTC>[2]> #> [1] {2000-01-03--2000-01-05}                         #> [2] {2000-01-01--2000-01-02, 2000-01-04--2000-01-09} jan_1_to_9 <- interval(ymd(\"2000-01-01\"), ymd(\"2000-01-09\")) jan_1_to_2 <- interval(ymd(\"2000-01-01\"), ymd(\"2000-01-02\")) jan_3_to_5 <- interval(ymd(\"2000-01-03\"), ymd(\"2000-01-05\")) jan_4_to_9 <- interval(ymd(\"2000-01-04\"), ymd(\"2000-01-09\"))  ints <- c(jan_1_to_2, jan_3_to_5, jan_4_to_9) phint_squash(ints) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-02, 2000-01-03--2000-01-09}"},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"example-employment-history","dir":"","previous_headings":"","what":"Example: Employment History","title":"Set Operations on Time Intervals","text":"phinterval package useful working tabular data, longitudinal employment panel. <phinterval> column formatting adapts available console width. \"[2]\" Greg’s employment interval \"{2018-01-01-[2]-2020-04-01}\" indicates employment history made two disjoint spans, first span beginning 2018-01-01 second ending 2020-04-01. space available, every span shown explicitly. Operations <phinterval> vectors behave like standard intervals. , can see 7-day gap Greg’s employment history:","code":"library(dplyr, warn.conflicts = FALSE)  jobs <- tribble(   ~name,   ~job_title,             ~start,        ~end,   \"Greg\",  \"Mascot\",               \"2018-01-01\",  \"2018-06-03\",   \"Greg\",  \"Executive Assistant\",  \"2018-06-10\",  \"2020-04-01\",   \"Shiv\",  \"Political Consultant\", \"2017-01-01\",  \"2019-04-01\" )  employment <- jobs |>   # Squash overlapping/adjacent intervals into a single phinterval   group_by(name) |>   summarize(employed = datetime_squash(ymd(start), ymd(end))) |>   # Invert the employment timeline to find gaps   mutate(unemployed = phint_invert(employed))  employment #> # A tibble: 2 × 3 #>   name  employed                    unemployed               #>   <chr> <phint<UTC>>                <phint<UTC>>             #> 1 Greg  {2018-01-01-[2]-2020-04-01} {2018-06-03--2018-06-10} #> 2 Shiv  {2017-01-01--2019-04-01}    <hole> employment |> select(name, employed) #> # A tibble: 2 × 2 #>   name  employed                                         #>   <chr> <phint<UTC>>                                     #> 1 Greg  {2018-01-01--2018-06-03, 2018-06-10--2020-04-01} #> 2 Shiv  {2017-01-01--2019-04-01} employment |>   mutate(     days_employed = employed / ddays(1),     days_unemployed = unemployed / ddays(1)   ) |>   select(name, days_employed, days_unemployed) #> # A tibble: 2 × 3 #>   name  days_employed days_unemployed #>   <chr>         <dbl>           <dbl> #> 1 Greg            814               7 #> 2 Shiv            820               0"},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"phinterval---lubridate","dir":"","previous_headings":"","what":"phinterval <-> lubridate","title":"Set Operations on Time Intervals","text":"<phinterval> class generalization <Interval> class, meaning <Interval> can converted equivalent <phinterval> phinterval functions accept either <Interval> <phinterval> inputs. table shows lubridate functions drop-phinterval replacements. phinterval set operations work expected arbitrary time spans, enabling operations supported lubridate. example, intersection two non-overlapping intervals empty time span, called <hole>. set-difference time span also <hole>. Performing set-difference may “punch hole” time span, creating discontinuous interval. union two disjoint intervals single <phinterval> containing two spans. lubridate equivalents, phinterval set operations vectorized.","code":"lubridate::intersect(jan_1_to_2, jan_4_to_9) #> [1] NA--NA phint_intersect(jan_1_to_2, jan_4_to_9) #> <phinterval<UTC>[1]> #> [1] <hole> lubridate::setdiff(jan_1_to_2, jan_1_to_2) #> [1] 2000-01-01 UTC--2000-01-02 UTC phint_setdiff(jan_1_to_2, jan_1_to_2) #> <phinterval<UTC>[1]> #> [1] <hole> try(lubridate::setdiff(jan_1_to_9, jan_3_to_5)) #> Error in setdiff.Interval(jan_1_to_9, jan_3_to_5) :  #>   Cases 1 result in discontinuous intervals. phint_setdiff(jan_1_to_9, jan_3_to_5) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-03, 2000-01-05--2000-01-09} lubridate::union(jan_1_to_2, jan_4_to_9) #> [1] 2000-01-01 UTC--2000-01-09 UTC phint_union(jan_1_to_2, jan_4_to_9) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-02, 2000-01-04--2000-01-09} phint_intersect(   c(jan_1_to_2, jan_3_to_5, jan_1_to_2),   c(jan_1_to_9, jan_4_to_9, jan_4_to_9) ) #> <phinterval<UTC>[3]> #> [1] {2000-01-01--2000-01-02} {2000-01-04--2000-01-05} <hole>"},{"path":"https://ethansansom.github.io/phinterval/index.html","id":"inspiration","dir":"","previous_headings":"","what":"Inspiration","title":"Set Operations on Time Intervals","text":"package builds {lubridate}’s <Interval> class representing contiguous time spans. prototype <phinterval> data structure (list matrices) C++ implementation phint_squash() inspired {intervals} package Richard Bourgon Edzer Pebesma. figures used README inspired Davis Vaughan’s {ivs} package documentation.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_duration.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a phinterval to a duration — as_duration","title":"Convert a phinterval to a duration — as_duration","text":"as_duration() converts lubridate::interval() phinterval() vector lubridate::duration() vector. resulting duration measures length time seconds within element interval phinterval. as_duration() wrapper around lubridate::.duration().","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_duration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a phinterval to a duration — as_duration","text":"","code":"as_duration(x, ...)  # Default S3 method as_duration(x, ...)  # S3 method for class 'phinterval' as_duration(x, ...)"},{"path":"https://ethansansom.github.io/phinterval/reference/as_duration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a phinterval to a duration — as_duration","text":"x [phinterval / Interval] object convert. ... Parameters passed methods. Currently unused.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_duration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a phinterval to a duration — as_duration","text":"<Duration> vector length x.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_duration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a phinterval to a duration — as_duration","text":"","code":"monday <- interval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) friday <- interval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\")) mon_and_fri <- phint_union(monday, friday)  as_duration(c(mon_and_fri, monday)) #> [1] \"172800s (~2 days)\" \"86400s (~1 days)\"  as_duration(mon_and_fri) == as_duration(monday) + as_duration(friday) #> [1] TRUE"},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an interval or datetime vector into a phinterval — as_phinterval","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"as_phinterval() converts lubridate::interval(), Date, POSIXct, POSIXlt vector equivalent <phinterval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"","code":"as_phinterval(x, ...)  # Default S3 method as_phinterval(x, ...)  # S3 method for class 'Interval' as_phinterval(x, ...)"},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"x [Interval / Date / POSIXct / POSIXlt] object convert. ... Additional arguments passed methods. Currently unused.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"<phinterval> vector length x.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"Negative intervals (start > end) standardized positive intervals via lubridate::int_standardize(). Datetime vectors (Date, POSIXct, POSIXlt) converted instantaneous intervals start end identical. Spans partially missing endpoints (e.g., interval(NA, end) interval(start, NA)) converted fully NA element.","code":""},{"path":[]},{"path":"https://ethansansom.github.io/phinterval/reference/as_phinterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an interval or datetime vector into a phinterval — as_phinterval","text":"","code":"# Convert Interval vector years <- interval(   start = as.Date(c(\"2021-01-01\", \"2023-01-01\")),   end = as.Date(c(\"2022-01-01\", \"2024-01-01\")) ) as_phinterval(years) #> <phinterval<UTC>[2]> #> [1] {2021-01-01--2022-01-01} {2023-01-01--2024-01-01}  # Negative intervals are standardized negative <- interval(as.Date(\"2000-10-11\"), as.Date(\"2000-10-01\")) as_phinterval(negative) #> <phinterval<UTC>[1]> #> [1] {2000-10-01--2000-10-11}  # Partially missing endpoints become fully NA partial_na <- interval(NA, as.Date(\"1999-08-02\")) as_phinterval(partial_na) #> <phinterval<UTC>[1]> #> [1] <NA>  # Datetime vectors become instantaneous intervals as_phinterval(as.Date(c(\"2000-10-11\", \"2001-05-03\"))) #> <phinterval<UTC>[2]> #> [1] {2000-10-11--2000-10-11} {2001-05-03--2001-05-03}"},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a hole phinterval — hole","title":"Create a hole phinterval — hole","text":"hole() creates <phinterval> vector element hole (empty set time spans).","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a hole phinterval — hole","text":"","code":"hole(n = 1L, tzone = \"\")"},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a hole phinterval — hole","text":"n [integer(1)] number hole elements create. Must positive whole number. tzone [character(1)] time zone display <phinterval> . Defaults \"\".","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a hole phinterval — hole","text":"<phinterval> vector length n element <hole>.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a hole phinterval — hole","text":"hole phinterval element zero time spans, representing empty interval. Holes useful placeholders representing absence time periods interval algebra operations.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/hole.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a hole phinterval — hole","text":"","code":"# Create a single hole hole() #> <phinterval<local>[1]> #> [1] <hole>  # Create multiple holes hole(3) #> <phinterval<local>[3]> #> [1] <hole> <hole> <hole>  # Specify time zone hole(tzone = \"UTC\") #> <phinterval<UTC>[1]> #> [1] <hole>  # Holes can be combined with other phintervals jan <- phinterval(as.Date(\"2000-01-01\"), as.Date(\"2000-02-01\")) c(jan, hole(), jan) #> <phinterval<UTC>[3]> #> [1] {2000-01-01--2000-02-01} <hole>                   {2000-01-01--2000-02-01}"},{"path":"https://ethansansom.github.io/phinterval/reference/is_hole.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for empty intervals — is_hole","title":"Test for empty intervals — is_hole","text":"is_hole() checks <hole> (empty) time spans phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_hole.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for empty intervals — is_hole","text":"","code":"is_hole(phint)"},{"path":"https://ethansansom.github.io/phinterval/reference/is_hole.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for empty intervals — is_hole","text":"phint [phinterval / Interval] <phinterval> <Interval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_hole.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for empty intervals — is_hole","text":"logical vector length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_hole.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for empty intervals — is_hole","text":"","code":"# Detect holes y2000 <- interval(as.Date(\"2000-01-01\"), as.Date(\"2001-01-01\")) y2025 <- interval(as.Date(\"2025-01-01\"), as.Date(\"2025-01-01\")) is_hole(c(hole(), y2000, hole(), y2025, NA)) #> [1]  TRUE FALSE  TRUE FALSE    NA  # The intersection of disjoint intervals is a hole is_hole(phint_intersect(y2000, y2025)) #> [1] TRUE"},{"path":"https://ethansansom.github.io/phinterval/reference/is_phinterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a phinterval — is_phinterval","title":"Test if the object is a phinterval — is_phinterval","text":"function returns TRUE <phinterval> vectors returns FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phinterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a phinterval — is_phinterval","text":"","code":"is_phinterval(x)"},{"path":"https://ethansansom.github.io/phinterval/reference/is_phinterval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a phinterval — is_phinterval","text":"x object test.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phinterval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a phinterval — is_phinterval","text":"TRUE x <phinterval>, FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phinterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a phinterval — is_phinterval","text":"","code":"is_phinterval(phinterval()) #> [1] TRUE is_phinterval(interval()) #> [1] FALSE"},{"path":"https://ethansansom.github.io/phinterval/reference/is_phintish.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a phinterval or interval — is_phintish","title":"Test if the object is a phinterval or interval — is_phintish","text":"function returns TRUE <phinterval> <Interval> vectors returns FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phintish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a phinterval or interval — is_phintish","text":"","code":"is_phintish(x)"},{"path":"https://ethansansom.github.io/phinterval/reference/is_phintish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a phinterval or interval — is_phintish","text":"x object test.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phintish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a phinterval or interval — is_phintish","text":"TRUE x <phinterval> <Interval>, FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_phintish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a phinterval or interval — is_phintish","text":"","code":"is_phinterval(phinterval()) #> [1] TRUE is_phinterval(interval()) #> [1] FALSE is_phinterval(as.Date(\"2020-01-01\")) #> [1] FALSE"},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a recognized time zone — is_recognized_tzone","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"is_recognized_tzone() returns TRUE strings recognized IANA time zone names, FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"","code":"is_recognized_tzone(x)"},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"x object test.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"TRUE x recognized time zone, FALSE otherwise.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"Recognized time zones listed tzdb::tzdb_names(), provides --date copy time zones IANA time zone database. <phinterval> vectors unrecognized time zone formatted using \"UTC\" time zone warning.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/is_recognized_tzone.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a recognized time zone — is_recognized_tzone","text":"","code":"is_recognized_tzone(\"UTC\") #> [1] TRUE is_recognized_tzone(\"America/New_York\") #> [1] TRUE is_recognized_tzone(\"\") #> [1] TRUE is_recognized_tzone(\"badzone\") #> [1] FALSE is_recognized_tzone(10L) #> [1] FALSE"},{"path":"https://ethansansom.github.io/phinterval/reference/n_spans.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of spans in a phinterval — n_spans","title":"Count the number of spans in a phinterval — n_spans","text":"n_spans() counts number disjoint time spans element phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/n_spans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of spans in a phinterval — n_spans","text":"","code":"n_spans(phint)  # Default S3 method n_spans(phint)  # S3 method for class 'Interval' n_spans(phint)  # S3 method for class 'phinterval' n_spans(phint)"},{"path":"https://ethansansom.github.io/phinterval/reference/n_spans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of spans in a phinterval — n_spans","text":"phint [phinterval / Interval] <phinterval> <Interval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/n_spans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of spans in a phinterval — n_spans","text":"integer vector length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/n_spans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of spans in a phinterval — n_spans","text":"","code":"# Count spans y2000 <- interval(as.Date(\"2000-01-01\"), as.Date(\"2001-01-01\")) y2025 <- interval(as.Date(\"2025-01-01\"), as.Date(\"2025-01-01\"))  n_spans(c(  phint_union(y2000, y2025),  phint_intersect(y2000, y2025),  y2000, y2025 )) #> [1] 2 0 1 1"},{"path":"https://ethansansom.github.io/phinterval/reference/params.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter Descriptions for phinterval Package — params","title":"Parameter Descriptions for phinterval Package — params","text":"Default parameter descriptions may overridden individual functions.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter Descriptions for phinterval Package — params","text":"phint1, phint2 [phinterval / Interval] pair <phinterval> <Interval> vectors. phint1 phint2 recycled common length using vctrs-style recycling. phint [phinterval / Interval] <phinterval> <Interval> vector. bounds [\"[]\" / \"()\"] Whether span endpoints inclusive exclusive: \"[]\" (default): Closed intervals - endpoints included \"()\": Open intervals - endpoints excluded affects adjacency overlap detection. example, bounds = \"[]\", intervals [1, 5] [5, 10] considered adjacent (share endpoint 5), bounds = \"()\", (1, 5) (5, 10) disjoint (neither includes 5).","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter Descriptions for phinterval Package — params","text":"value NULL.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_invert.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the gaps in a phinterval as time spans — phint_invert","title":"Get the gaps in a phinterval as time spans — phint_invert","text":"phint_invert() returns gaps within phinterval <phinterval> vector. phintervals multiple disjoint spans, gaps spans returned. Contiguous time spans (e.g., lubridate::interval() vectors) gaps inverted holes. phint_invert() similar phint_complement(), except time occurring outside extent phint (earliest start latest end) included result.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_invert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the gaps in a phinterval as time spans — phint_invert","text":"","code":"phint_invert(phint, hole_to = c(\"hole\", \"inf\", \"na\"))"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_invert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the gaps in a phinterval as time spans — phint_invert","text":"phint [phinterval / Interval] <phinterval> <Interval> vector. hole_to [\"hole\" / \"inf\" / \"na\"] handle holes (empty phinterval elements): \"hole\" (default): Holes remain holes \"inf\": Return span -Inf Inf (time) \"na\": Return NA phinterval","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_invert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the gaps in a phinterval as time spans — phint_invert","text":"<phinterval> vector length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_invert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the gaps in a phinterval as time spans — phint_invert","text":"","code":"monday <- interval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) friday <- interval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\")) sunday <- interval(as.Date(\"2025-11-16\"), as.Date(\"2025-11-17\"))  # Contiguous intervals have no gaps (inverted to holes) phint_invert(monday) #> <phinterval<UTC>[1]> #> [1] <hole>  # Disjoint intervals: gaps between spans are returned phint_invert(phint_squash(c(monday, friday, sunday))) #> <phinterval<UTC>[1]> #> [1] {2025-11-11--2025-11-14, 2025-11-15--2025-11-16}  # The gap between Monday and Friday is Tuesday through Thursday tues_to_thurs <- interval(as.Date(\"2025-11-11\"), as.Date(\"2025-11-14\")) phint_invert(phint_union(monday, friday)) == tues_to_thurs #> [1] TRUE  # Invert vs complement: time before and after is excluded from invert mon_and_fri <- phint_union(monday, friday) phint_invert(mon_and_fri) #> <phinterval<UTC>[1]> #> [1] {2025-11-11--2025-11-14} phint_complement(mon_and_fri) #> <phinterval<UTC>[1]> #> [1] {-Inf-[3]-Inf}  # How to invert holes hole <- phint_intersect(monday, friday) phint_invert(hole, hole_to = \"hole\") #> <phinterval<UTC>[1]> #> [1] <hole> phint_invert(hole, hole_to = \"inf\") #> <phinterval<UTC>[1]> #> [1] {-Inf--Inf} phint_invert(hole, hole_to = \"na\") #> <phinterval<UTC>[1]> #> [1] <NA>"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the length of a phinterval in seconds — phint_length","title":"Compute the length of a phinterval in seconds — phint_length","text":"phint_length() calculates total length time spans within phinterval element seconds. phintervals multiple disjoint spans, lengths summed. Instantaneous intervals holes length 0. phint_lengths() returns individual length seconds time span within phinterval element.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the length of a phinterval in seconds — phint_length","text":"","code":"phint_length(phint)  # Default S3 method phint_length(phint)  # S3 method for class 'Interval' phint_length(phint)  # S3 method for class 'phinterval' phint_length(phint)  phint_lengths(phint)  # Default S3 method phint_lengths(phint)  # S3 method for class 'Interval' phint_lengths(phint)  # S3 method for class 'phinterval' phint_lengths(phint)"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the length of a phinterval in seconds — phint_length","text":"phint [phinterval / Interval] <phinterval> <Interval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the length of a phinterval in seconds — phint_length","text":"phint_length(), numeric vector length phint. phint_lengths(), list numeric vectors length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the length of a phinterval in seconds — phint_length","text":"","code":"monday <- interval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) friday <- interval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\"))  phint_length(monday) #> [1] 86400 phint_length(phint_intersect(monday, friday)) #> [1] 0  # phint_length() sums the lengths of disjoint time spans mon_and_fri <- phint_union(monday, friday) phint_length(mon_and_fri) == phint_length(monday) + phint_length(friday) #> [1] TRUE  # phint_lengths() returns the length of each disjoint time span phint_lengths(mon_and_fri) #> [[1]] #> [1] 86400 86400 #>"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_overlaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether two phintervals overlap — phint_overlaps","title":"Test whether two phintervals overlap — phint_overlaps","text":"phint_overlaps() tests whether -th element phint1 overlaps -th element phint2, returning logical vector. Adjacent intervals (one ends exactly begins) considered overlapping. phint1 phint2 recycled common length using vctrs-style recycling rules.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_overlaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether two phintervals overlap — phint_overlaps","text":"","code":"phint_overlaps(phint1, phint2, bounds = c(\"[]\", \"()\"))"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_overlaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test whether two phintervals overlap — phint_overlaps","text":"phint1, phint2 [phinterval / Interval] pair <phinterval> <Interval> vectors. phint1 phint2 recycled common length using vctrs-style recycling. bounds [\"[]\" / \"()\"] Whether span endpoints inclusive exclusive: \"[]\" (default): Closed intervals - endpoints included \"()\": Open intervals - endpoints excluded affects adjacency overlap detection. example, bounds = \"[]\", intervals [1, 5] [5, 10] considered adjacent (share endpoint 5), bounds = \"()\", (1, 5) (5, 10) disjoint (neither includes 5).","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_overlaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test whether two phintervals overlap — phint_overlaps","text":"logical vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_overlaps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test whether two phintervals overlap — phint_overlaps","text":"","code":"monday <- interval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) tuesday <- interval(as.Date(\"2025-11-11\"), as.Date(\"2025-11-12\")) friday <- interval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\")) mon_and_fri <- phint_union(monday, friday)  phint_overlaps(c(monday, monday, friday), c(mon_and_fri, friday, NA)) #> [1]  TRUE FALSE    NA  # Adjacent intervals are considered overlapping by default phint_overlaps(monday, tuesday) #> [1] TRUE  # Use exclusive bounds to consider adjacent intervals as disjoint phint_overlaps(monday, tuesday, bounds = \"()\") #> [1] FALSE  # Holes never overlap with anything (including other holes) hole <- hole() phint_overlaps(c(hole, monday), c(hole, hole)) #> [1] FALSE FALSE"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_sift.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove instantaneous time spans from a phinterval — phint_sift","title":"Remove instantaneous time spans from a phinterval — phint_sift","text":"phint_sift() removes instantaneous spans (spans 0 duration) phinterval elements. spans element instantaneous, result hole.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_sift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove instantaneous time spans from a phinterval — phint_sift","text":"","code":"phint_sift(phint)"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_sift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove instantaneous time spans from a phinterval — phint_sift","text":"phint [phinterval / Interval] <phinterval> <Interval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_sift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove instantaneous time spans from a phinterval — phint_sift","text":"<phinterval> vector length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_sift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove instantaneous time spans from a phinterval — phint_sift","text":"","code":"y2020 <- interval(as.Date(\"2020-01-01\"), as.Date(\"2021-01-01\")) y2021 <- interval(as.Date(\"2021-01-01\"), as.Date(\"2022-01-01\")) y2022 <- interval(as.Date(\"2022-01-01\"), as.Date(\"2023-01-01\"))  # The intersection of two adjacent intervals is instantaneous new_years_2021 <- phint_intersect(y2020, y2021) new_years_2021 #> <phinterval<UTC>[1]> #> [1] {2021-01-01--2021-01-01} phint_sift(new_years_2021) #> <phinterval<UTC>[1]> #> [1] <hole>  # phint_sift() removes instants while keeping non-instantaneous spans y2022_and_new_years <- phint_union(y2022, new_years_2021) y2022_and_new_years #> <phinterval<UTC>[1]> #> [1] {2021-01-01--2021-01-01, 2022-01-01--2023-01-01} phint_sift(y2022_and_new_years) #> <phinterval<UTC>[1]> #> [1] {2022-01-01--2023-01-01}"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest a phinterval into a data frame — phint_unnest","title":"Unnest a phinterval into a data frame — phint_unnest","text":"phint_unnest() converts <phinterval> vector tibble::tibble() time span becomes row.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest a phinterval into a data frame — phint_unnest","text":"","code":"phint_unnest(phint, hole_to = c(\"drop\", \"na\"), keep_size = FALSE, key = NULL)"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest a phinterval into a data frame — phint_unnest","text":"phint [phinterval / Interval] <phinterval> <Interval> vector unnest. hole_to [\"drop\" / \"na\"] handle hole elements (phintervals zero spans). \"drop\" (default), holes excluded output. \"na\", row NA start end times included hole. keep_size [TRUE / FALSE] size column included output? TRUE, output includes size column containing number spans original phinterval element. FALSE (default), key, start, end columns returned. key [vector / data.frame / NULL] optional vector data frame use key column output. provided, must length phint. NULL (default), key column contains row indices (position phint). key may vector vctrs sense. See vctrs::obj_is_vector() details.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest a phinterval into a data frame — phint_unnest","text":"tibble::tibble() columns: key: key = NULL: numeric vector identifying index phinterval element Otherwise: element key corresponding phinterval element start: POSIXct start time span end: POSIXct end time span size: (keep_size = TRUE) Integer count spans phinterval element","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Unnest a phinterval into a data frame — phint_unnest","text":"phint_unnest() expands phinterval element constituent time spans, creating one row per span. resulting data frame contains key column identifying phinterval element span came , along start end columns span boundaries. phinterval elements containing multiple disjoint spans, spans included key value. Scalar phinterval elements (single spans) produce single row.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_unnest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest a phinterval into a data frame — phint_unnest","text":"","code":"# Unnest scalar phintervals phint <- phinterval(   start = as.Date(c(\"2000-01-01\", \"2000-02-01\")),   end = as.Date(c(\"2000-01-15\", \"2000-02-15\")) ) phint_unnest(phint) #> # A tibble: 2 × 3 #>     key start               end                 #>   <dbl> <dttm>              <dttm>              #> 1     1 2000-01-01 00:00:00 2000-01-15 00:00:00 #> 2     2 2000-02-01 00:00:00 2000-02-15 00:00:00  # Unnest multi-span phinterval phint <- phinterval(   start = as.Date(c(\"2000-01-01\", \"2000-03-01\")),   end = as.Date(c(\"2000-01-15\", \"2000-03-15\")),   by = 1 ) phint_unnest(phint) #> # A tibble: 2 × 3 #>     key start               end                 #>   <dbl> <dttm>              <dttm>              #> 1     1 2000-01-01 00:00:00 2000-01-15 00:00:00 #> 2     1 2000-03-01 00:00:00 2000-03-15 00:00:00  # Handle holes phint <- c(   phinterval(as.Date(\"2000-01-01\"), as.Date(\"2000-01-15\")),   hole(),   phinterval(as.Date(\"2000-02-01\"), as.Date(\"2000-02-15\")) ) phint_unnest(phint, hole_to = \"drop\") #> # A tibble: 2 × 3 #>     key start               end                 #>   <dbl> <dttm>              <dttm>              #> 1     1 2000-01-01 00:00:00 2000-01-15 00:00:00 #> 2     3 2000-02-01 00:00:00 2000-02-15 00:00:00 phint_unnest(phint, hole_to = \"na\") #> # A tibble: 3 × 3 #>     key start               end                 #>   <dbl> <dttm>              <dttm>              #> 1     1 2000-01-01 00:00:00 2000-01-15 00:00:00 #> 2     2 NA                  NA                  #> 3     3 2000-02-01 00:00:00 2000-02-15 00:00:00  # Include size column phint_unnest(phint, keep_size = TRUE, hole_to = \"na\") #> # A tibble: 3 × 4 #>     key start               end                  size #>   <dbl> <dttm>              <dttm>              <int> #> 1     1 2000-01-01 00:00:00 2000-01-15 00:00:00     1 #> 2     2 NA                  NA                      0 #> 3     3 2000-02-01 00:00:00 2000-02-15 00:00:00     1  # Use a custom `key` phint_unnest(phint, key = c(\"A\", \"B\", \"C\"), hole_to = \"na\") #> # A tibble: 3 × 3 #>   key   start               end                 #>   <chr> <dttm>              <dttm>              #> 1 A     2000-01-01 00:00:00 2000-01-15 00:00:00 #> 2 B     NA                  NA                  #> 3 C     2000-02-01 00:00:00 2000-02-15 00:00:00"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_within.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether a datetime or phinterval is within another phinterval — phint_within","title":"Test whether a datetime or phinterval is within another phinterval — phint_within","text":"phint_within() tests whether -th element x contained within -th element phint, returning logical vector. x may datetime (Date, POSIXct, POSIXlt), lubridate::interval(), phinterval(), phint must lubridate::interval() phinterval(). x phint recycled common length using vctrs-style recycling rules. Datetimes endpoint interval considered within interval. interval considered within .","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_within.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether a datetime or phinterval is within another phinterval — phint_within","text":"","code":"phint_within(x, phint, bounds = c(\"[]\", \"()\"))"},{"path":"https://ethansansom.github.io/phinterval/reference/phint_within.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test whether a datetime or phinterval is within another phinterval — phint_within","text":"x [phinterval / Interval / Date / POSIXct / POSIXlt] object test. phint [phinterval / Interval] <phinterval> <Interval> vector. bounds [\"[]\" / \"()\"] Whether span endpoints inclusive exclusive: \"[]\" (default): Closed intervals - endpoints included \"()\": Open intervals - endpoints excluded affects adjacency overlap detection. example, bounds = \"[]\", intervals [1, 5] [5, 10] considered adjacent (share endpoint 5), bounds = \"()\", (1, 5) (5, 10) disjoint (neither includes 5).","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_within.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test whether a datetime or phinterval is within another phinterval — phint_within","text":"logical vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phint_within.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test whether a datetime or phinterval is within another phinterval — phint_within","text":"","code":"jan_1_to_5 <- interval(as.Date(\"2000-01-01\"), as.Date(\"2000-01-05\")) jan_2_to_4 <- interval(as.Date(\"2000-01-02\"), as.Date(\"2000-01-04\")) jan_3_to_9 <- interval(as.Date(\"2000-01-03\"), as.Date(\"2000-01-09\"))  phint_within(   c(jan_2_to_4, jan_3_to_9, jan_1_to_5),   c(jan_1_to_5, jan_1_to_5, NA) ) #> [1]  TRUE FALSE    NA  phint_within(as.Date(c(\"2000-01-06\", \"2000-01-20\")), jan_3_to_9) #> [1]  TRUE FALSE  # Intervals are within themselves phint_within(jan_1_to_5, jan_1_to_5) #> [1] TRUE  # By default, interval endpoints are considered within phint_within(as.Date(\"2000-01-01\"), jan_1_to_5) #> [1] TRUE  # Use bounds to consider intervals as exclusive of endpoints phint_within(as.Date(\"2000-01-01\"), jan_1_to_5, bounds = \"()\") #> [1] FALSE  # Holes are never within any interval (including other holes) hole <- hole() phint_within(c(hole, hole), c(hole, jan_1_to_5)) #> [1] FALSE FALSE"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-accessors.html","id":null,"dir":"Reference","previous_headings":"","what":"Accessors for the endpoints of a phinterval — phinterval-accessors","title":"Accessors for the endpoints of a phinterval — phinterval-accessors","text":"phint_start() phint_end() return earliest latest endpoint phinterval element, respectively. Holes (empty time spans) returned NA. phint_starts() phint_ends() return lists start end points phinterval element, respectively. phintervals multiple disjoint spans, span's endpoint included. Holes returned length-0 <POSIXct> vectors.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-accessors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accessors for the endpoints of a phinterval — phinterval-accessors","text":"","code":"phint_start(phint)  # Default S3 method phint_start(phint)  # S3 method for class 'Interval' phint_start(phint)  # S3 method for class 'phinterval' phint_start(phint)  phint_end(phint)  # Default S3 method phint_end(phint)  # S3 method for class 'Interval' phint_end(phint)  # S3 method for class 'phinterval' phint_end(phint)  phint_starts(phint)  # Default S3 method phint_starts(phint)  # S3 method for class 'Interval' phint_starts(phint)  # S3 method for class 'phinterval' phint_starts(phint)  phint_ends(phint)  # Default S3 method phint_ends(phint)  # S3 method for class 'Interval' phint_ends(phint)  # S3 method for class 'phinterval' phint_ends(phint)"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-accessors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accessors for the endpoints of a phinterval — phinterval-accessors","text":"phint [phinterval / Interval] <phinterval> <Interval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-accessors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accessors for the endpoints of a phinterval — phinterval-accessors","text":"phint_start() phint_end(), <POSIXct> vector length phint. phint_starts() phint_ends(), list <POSIXct> vectors length phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-accessors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Accessors for the endpoints of a phinterval — phinterval-accessors","text":"","code":"int1 <- interval(as.Date(\"2020-01-10\"), as.Date(\"2020-02-01\")) int2 <- interval(as.Date(\"2023-05-02\"), as.Date(\"2023-06-03\"))  phint_start(int1) #> [1] \"2020-01-10 UTC\" phint_end(int1) #> [1] \"2020-02-01 UTC\"  # Holes have no endpoints; disjoint phintervals have multiple endpoints hole <- phint_intersect(int1, int2) disjoint <- phint_union(int1, int2)  phint_start(c(hole, disjoint)) #> [1] NA               \"2020-01-10 UTC\" phint_starts(c(hole, disjoint)) #> [[1]] #> POSIXct of length 0 #>  #> [[2]] #> [1] \"2020-01-10 UTC\" \"2023-05-02 UTC\" #>   phint_end(c(hole, disjoint)) #> [1] NA               \"2023-06-03 UTC\" phint_ends(c(hole, disjoint)) #> [[1]] #> POSIXct of length 0 #>  #> [[2]] #> [1] \"2020-02-01 UTC\" \"2023-06-03 UTC\" #>   # phint_start() and phint_end() return the minimum and maximum endpoints negative <- interval(as.Date(\"1980-01-01\"), as.Date(\"1979-12-27\")) phint_start(negative) #> [1] \"1979-12-27 UTC\" phint_end(negative) #> [1] \"1980-01-01 UTC\""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phinterval: Set Operations on Time Intervals — phinterval-package","title":"phinterval: Set Operations on Time Intervals — phinterval-package","text":"Implements phinterval vector class representing time spans may contain gaps (disjoint intervals) empty. class generalizes 'lubridate' package's interval class support vectorized set operations (intersection, union, difference, complement) always return valid time span, even disjoint empty intervals created.","code":""},{"path":[]},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phinterval: Set Operations on Time Intervals — phinterval-package","text":"Maintainer: Ethan Sansom ethan.sansom29@gmail.com (ORCID) [copyright holder]","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-set-operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized set operations — phinterval-set-operations","title":"Vectorized set operations — phinterval-set-operations","text":"functions perform elementwise set operations <phinterval> vectors, treating element set non-overlapping intervals. return new <phinterval> vector representing result corresponding set operation. functions follow vctrs-style recycling rules. phint_complement() returns time spans covered phint. phint_union() returns intervals within either phint1 phint2. phint_intersect() returns intervals within phint1 phint2. phint_setdiff() returns intervals phint1 within phint2.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-set-operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized set operations — phinterval-set-operations","text":"","code":"phint_complement(phint)  phint_union(phint1, phint2)  phint_intersect(phint1, phint2, bounds = c(\"[]\", \"()\"))  phint_setdiff(phint1, phint2)"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-set-operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized set operations — phinterval-set-operations","text":"phint [phinterval / Interval] <phinterval> <Interval> vector. phint1, phint2 [phinterval / Interval] pair <phinterval> <Interval> vectors. phint1 phint2 recycled common length using vctrs-style recycling. bounds [\"[]\" / \"()\"] phint_intersect() , whether span endpoints inclusive exclusive: \"[]\" (default): Closed intervals - endpoints included \"()\": Open intervals - endpoints excluded affects adjacency overlap detection. example, bounds = \"[]\", intervals [1, 5] [5, 10] considered adjacent (share endpoint 5), bounds = \"()\", (1, 5) (5, 10) disjoint (neither includes 5).","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-set-operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized set operations — phinterval-set-operations","text":"<phinterval> vector.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval-set-operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized set operations — phinterval-set-operations","text":"","code":"monday <- interval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) tuesday <- interval(as.Date(\"2025-11-11\"), as.Date(\"2025-11-12\")) friday <- interval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\")) jan_1_to_5 <- interval(as.Date(\"2000-01-01\"), as.Date(\"2000-01-05\")) jan_3_to_9 <- interval(as.Date(\"2000-01-03\"), as.Date(\"2000-01-09\"))  # Complement phint_complement(jan_1_to_5) #> <phinterval<UTC>[1]> #> [1] {-Inf--2000-01-01, 2000-01-05--Inf}  # The complement of a hole is an infinite span covering all time hole <- hole() phint_complement(hole) #> <phinterval<local>[1]> #> [1] {-Inf--Inf}  # Union phint_union(c(monday, monday, monday), c(tuesday, friday, NA)) #> <phinterval<UTC>[3]> #> [1] {2025-11-10--2025-11-12}                         #> [2] {2025-11-10--2025-11-11, 2025-11-14--2025-11-15} #> [3] <NA>                                              # Elements of length 1 are recycled phint_union(monday, c(tuesday, friday, NA)) #> <phinterval<UTC>[3]> #> [1] {2025-11-10--2025-11-12}                         #> [2] {2025-11-10--2025-11-11, 2025-11-14--2025-11-15} #> [3] <NA>                                              # Intersection phint_intersect(jan_1_to_5, jan_3_to_9) #> <phinterval<UTC>[1]> #> [1] {2000-01-03--2000-01-05}  # The intersection of non-overlapping intervals is a hole phint_intersect(monday, friday) #> <phinterval<UTC>[1]> #> [1] <hole>  # By default, the intersection of adjacent intervals is instantaneous phint_intersect(monday, tuesday) #> <phinterval<UTC>[1]> #> [1] {2025-11-11--2025-11-11}  # Use bounds to set the intersection of adjacent intervals to a hole phint_intersect(monday, tuesday, bounds = \"()\") #> <phinterval<UTC>[1]> #> [1] <hole>  # Set difference phint_setdiff(jan_1_to_5, jan_3_to_9) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-03} phint_setdiff(jan_3_to_9, jan_1_to_5) #> <phinterval<UTC>[1]> #> [1] {2000-01-05--2000-01-09}  # Instantaneous intervals do not affect the set difference noon_monday <- as.POSIXct(\"2025-11-10 12:00:00\") phint_setdiff(monday, interval(noon_monday, noon_monday)) == monday #> [1] TRUE"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new phinterval — phinterval","title":"Create a new phinterval — phinterval","text":"phinterval() creates new <phinterval> vector start end times. phinterval (think \"potentially holey interval\") span time may contain gaps.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new phinterval — phinterval","text":"","code":"phinterval(   start = POSIXct(),   end = POSIXct(),   tzone = NULL,   by = NULL,   order_by = FALSE )"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new phinterval — phinterval","text":"start, end [POSIXct / POSIXlt / Date] pair datetime vectors represent endpoints spans. start end recycled common length using vctrs-style recycling rules. tzone [character(1)] time zone display <phinterval> . tzone NULL (default), time zone taken start. tzone can non-NA string, unrecognized time zones (see is_recognized_tzone()) formatted using \"UTC\" warning. [vector / data.frame / NULL] optional grouping vector data frame. provided, start[] end[] pairs grouped [], creating one phinterval element per unique value . Overlapping abutting spans within group merged. NULL (default), start/end pair creates separate phinterval element. recycled match common length start end. may vector vctrs sense. See vctrs::obj_is_vector() details. order_by [TRUE / FALSE] output ordered values ? FALSE (default), output order matches first appearance group . TRUE, output sorted unique values . used NULL.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new phinterval — phinterval","text":"= NULL, <phinterval> vector length recycled length start end. provided, <phinterval> vector one element per unique value .","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a new phinterval — phinterval","text":"<phinterval> class designed generalization lubridate::interval(). <Interval> element represents single contiguous span two fixed times, <phinterval> element can represent time span may empty, contiguous, disjoint (.e. containing gaps). element <phinterval> stored (possibly empty) set non-overlapping non-abutting time spans. = NULL (default), phinterval() creates scalar phinterval elements, element contains single time span start[] end[]. equivalent lubridate::interval():   provided, phinterval() groups start/end pairs values , creating phinterval elements may contain multiple disjoint time spans. Overlapping abutting spans within group automatically merged.","code":"interval(start, end, tzone = tzone)   # <Interval> vector phinterval(start, end, tzone = tzone) # <phinterval> vector"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"differences-from-interval-","dir":"Reference","previous_headings":"","what":"Differences from interval()","title":"Create a new phinterval — phinterval","text":"phinterval() designed drop-replacement lubridate::interval(), three key differences regarding start end arguments: Stricter recycling: phinterval() uses vctrs recycling rules instead base R recycling. Length-1 vectors recycle length, mismatched lengths (e.g., 2 vs 3) cause error. character inputs: phinterval() accept character vectors start end. Character starts ends (e.g. \"2021-01-01\") must converted datetimes first using .POSIXct(), lubridate::ymd(), similar function. Standardized endpoints: lubridate::interval() allows negative length spans end[] < start[]. phinterval() flips order -th span's endpoints end[] < start[] ensure spans positive, similar lubridate::int_standardize().","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new phinterval — phinterval","text":"","code":"# Scalar phintervals (equivalent to interval()) phinterval(   start = as.Date(c(\"2000-01-01\", \"2000-02-01\")),   end = as.Date(c(\"2000-02-01\", \"2000-03-01\")) ) #> <phinterval<UTC>[2]> #> [1] {2000-01-01--2000-02-01} {2000-02-01--2000-03-01}  # Grouped phintervals with multiple spans per element phinterval(   start = as.Date(c(\"2000-01-01\", \"2000-03-01\", \"2000-02-01\")),   end = as.Date(c(\"2000-02-01\", \"2000-04-01\", \"2000-03-01\")),   by = c(1, 1, 2) ) #> <phinterval<UTC>[2]> #> [1] {2000-01-01--2000-02-01, 2000-03-01--2000-04-01} #> [2] {2000-02-01--2000-03-01}                          # Overlapping spans are merged within groups phinterval(   start = as.Date(c(\"2000-01-01\", \"2000-01-15\")),   end = as.Date(c(\"2000-02-01\", \"2000-02-15\")),   by = 1 ) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-02-15}  # Empty phinterval phinterval() #> <phinterval<UTC>[0]>  # Specify time zone phinterval(   start = as.Date(\"2000-01-01\"),   end = as.Date(\"2000-02-01\"),   tzone = \"America/New_York\" ) #> <phinterval<America/New_York>[1]> #> [1] {1999-12-31 19:00:00--2000-01-31 19:00:00}"},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Package options — phinterval_options","title":"Package options — phinterval_options","text":"phinterval package uses following global options control printing default behaviors. options can set using options() queried using getOption().","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval_options.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"Package options — phinterval_options","text":"phinterval.print_max_width: Character width printed formatted <phinterval> element truncated display, default: 90.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/phinterval_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Package options — phinterval_options","text":"","code":"monday <- phinterval(as.Date(\"2025-11-10\"), as.Date(\"2025-11-11\")) friday <- phinterval(as.Date(\"2025-11-14\"), as.Date(\"2025-11-15\"))  # Get the default setting getOption(\"phinterval.print_max_width\") #> [1] 90 phint_squash(c(monday, friday)) #> <phinterval<UTC>[1]> #> [1] {2025-11-10--2025-11-11, 2025-11-14--2025-11-15}  # Change the setting for the session duration opts <- options(phinterval.print_max_width = 25) phint_squash(c(monday, friday)) #> <phinterval<UTC>[1]> #> [1] <phint[2]>  # Reset to the previous settings options(opts)"},{"path":"https://ethansansom.github.io/phinterval/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. lubridate duration, interval, NA_POSIXct_, POSIXct tzdb tzdb_names, tzdb_version","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":null,"dir":"Reference","previous_headings":"","what":"Squash overlapping intervals into non-overlapping spans — squash","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"phint_squash() datetime_squash() merge overlapping adjacent intervals minimal set non-overlapping, non-adjacent time spans. phint_squash() takes <phinterval> <Interval> vector datetime_squash() takes separate start end datetime vectors = NULL (default), intervals merged single phinterval element. provided, intervals grouped merged separately within group, creating one phinterval element per unique value .","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"","code":"phint_squash(   phint,   by = NULL,   na.rm = TRUE,   empty_to = c(\"hole\", \"na\", \"empty\"),   order_by = FALSE,   keep_by = FALSE )  datetime_squash(   start,   end,   by = NULL,   na.rm = TRUE,   empty_to = c(\"hole\", \"na\", \"empty\"),   order_by = FALSE,   keep_by = FALSE )"},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"phint [phinterval / Interval] <phinterval> <Interval> vector. [vector / data.frame / NULL] optional grouping vector data frame. provided, intervals grouped merged separately within group. NULL (default), intervals merged single phinterval element. datetime_squash(), must recyclable recycled length start end. may vector vctrs sense. See vctrs::obj_is_vector() details. na.rm [TRUE / FALSE] NA elements removed squashing? FALSE NA elements present, result group NA. Defaults TRUE. empty_to [\"hole\" / \"na\" / \"empty\"] handle empty inputs (length-0 vectors groups NA values na.rm = TRUE): \"hole\" (default): Return hole \"na\": Return NA phinterval \"empty\": Return length-0 phinterval vector order_by [TRUE / FALSE] output ordered values ? FALSE (default), output order matches first appearance group . TRUE, output sorted unique values . used NULL. keep_by [TRUE / FALSE] values returned alongside result? FALSE (default), returns <phinterval> vector. TRUE, returns tibble::tibble() columns phint. Requires non-NULL. start [POSIXct / POSIXlt / Date] vector start times. Must recyclable end. used datetime_squash(). end [POSIXct / POSIXlt / Date] vector end times. Must recyclable start. used datetime_squash().","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"keep_by = FALSE: = NULL: length-1 <phinterval> vector (length-0 input empty empty_to = \"empty\") provided: <phinterval> vector one element per unique value keep_by = TRUE: tibble::tibble() columns phint.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"functions particularly useful aggregation workflows dplyr::summarize() combine intervals within groups.","code":""},{"path":"https://ethansansom.github.io/phinterval/reference/squash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Squash overlapping intervals into non-overlapping spans — squash","text":"","code":"jan_1_to_5 <- interval(as.Date(\"2000-01-01\"), as.Date(\"2000-01-05\")) jan_3_to_9 <- interval(as.Date(\"2000-01-03\"), as.Date(\"2000-01-09\")) jan_11_to_12 <- interval(as.Date(\"2000-01-11\"), as.Date(\"2000-01-12\"))  # phint_squash: merge intervals from a phinterval/Interval vector phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12)) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-09, 2000-01-11--2000-01-12}  # datetime_squash: merge intervals from start/end vectors datetime_squash(   start = as.Date(c(\"2000-01-01\", \"2000-01-03\", \"2000-01-11\")),   end = as.Date(c(\"2000-01-05\", \"2000-01-09\", \"2000-01-12\")) ) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-09, 2000-01-11--2000-01-12}  # NA values are removed by default phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12, NA)) #> <phinterval<UTC>[1]> #> [1] {2000-01-01--2000-01-09, 2000-01-11--2000-01-12}  # Set na.rm = FALSE to propagate NA values phint_squash(c(jan_1_to_5, jan_3_to_9, jan_11_to_12, NA), na.rm = FALSE) #> <phinterval<UTC>[1]> #> [1] <NA>  # Squash within groups phint_squash(   c(jan_1_to_5, jan_3_to_9, jan_11_to_12),   by = c(1, 1, 2) ) #> <phinterval<UTC>[2]> #> [1] {2000-01-01--2000-01-09} {2000-01-11--2000-01-12}  # Return a data frame with by values phint_squash(   c(jan_1_to_5, jan_3_to_9, jan_11_to_12),   by = c(\"A\", \"A\", \"B\"),   keep_by = TRUE ) #> # A tibble: 2 × 2 #>   by    phint                    #>   <chr> <phint<UTC>>             #> 1 A     {2000-01-01--2000-01-09} #> 2 B     {2000-01-11--2000-01-12}  # Control output order with order_by phint_squash(   c(jan_1_to_5, jan_3_to_9, jan_11_to_12),   by = c(2, 2, 1),   order_by = TRUE ) #> <phinterval<UTC>[2]> #> [1] {2000-01-11--2000-01-12} {2000-01-01--2000-01-09}  # empty_to determines the result of empty inputs empty <- phinterval() phint_squash(empty, empty_to = \"hole\") #> <phinterval<UTC>[1]> #> [1] <hole> phint_squash(empty, empty_to = \"na\") #> <phinterval<UTC>[1]> #> [1] <NA> phint_squash(empty, empty_to = \"empty\") #> <phinterval<UTC>[0]>"},{"path":"https://ethansansom.github.io/phinterval/news/index.html","id":"phinterval-100","dir":"Changelog","previous_headings":"","what":"phinterval 1.0.0","title":"phinterval 1.0.0","text":"Initial CRAN submission.","code":""}]
